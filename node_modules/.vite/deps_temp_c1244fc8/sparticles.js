import "./chunk-PLDDJCW6.js";

// node_modules/sparticles/dist/sparticles.mjs
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AnimationFrame = function AnimationFrame2() {
  var handler = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
  };
  var fps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 60;
  this.fps = fps;
  this.handler = handler;
  var renderId = 0;
  this.start = function() {
    var _this = this;
    if (!this.started) {
      var then = performance.now();
      var interval = 1e3 / this.fps;
      var tolerance = 0;
      var loop = function loop2(now) {
        var delta = now - then;
        renderId = requestAnimationFrame(loop2);
        if (delta >= interval - tolerance) {
          _this.handler(delta);
          then = now - delta % interval;
        }
      };
      renderId = requestAnimationFrame(loop);
      this.started = true;
    }
  };
  this.stop = function() {
    cancelAnimationFrame(renderId);
    this.started = false;
  };
};
var cartesian = function cartesian2(angle) {
  return [Math.cos(radian(angle - 90)), Math.sin(radian(angle - 90))];
};
var clamp = function clamp2(value) {
  var min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(min, Math.min(max, value));
};
var radian = function radian2(angle) {
  return angle * Math.PI / 180;
};
var random = function random2() {
  var min = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var max = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Math.random();
  if (max <= min) {
    value = min;
  } else if ((min !== 0 || max !== 1) && max > min) {
    value = value * (max - min) + min;
  }
  return value;
};
var randomArray = function randomArray2(array) {
  return array[Math.floor(random(0, array.length))];
};
var randomHsl = function randomHsl2() {
  var h = round(random(0, 360));
  var s = round(random(90, 100));
  var l = round(random(45, 85));
  return "hsl(".concat(h, ",").concat(s, "%,").concat(l, "%)");
};
var roll = function roll2(odds) {
  return odds > random();
};
var round = function round2(value) {
  return 0.5 + value | 0;
};
var Sparticle = function Sparticle2(parent) {
  if (parent) {
    this.canvas = parent.canvas;
    this.settings = parent.settings;
    this.colors = parent.colors;
    this.shapes = parent.shapes;
    this.images = parent.images;
    this.styles = parent.styles;
    this.ctx = parent.canvas.getContext("2d");
    this.setup();
    this.init();
  } else {
    console.warn("Invalid parameters given to Sparticle()", arguments);
  }
  return this;
};
Sparticle.prototype.setup = function() {
  var _ = this.settings;
  this.frame = 0;
  this.frameoffset = round(random(0, 360));
  this.size = round(random(_.minSize, _.maxSize));
  this.da = this.getAlphaDelta();
  this.dx = this.getDeltaX();
  this.dy = this.getDeltaY();
  this.dd = this.getDriftDelta();
  this.dr = this.getRotationDelta();
  this.color = this.getColor();
  this.shape = this.getShape();
  this.image = this.getImage();
  this.style = this.getStyle();
  this.rotation = _.rotate ? radian(random(0, 360)) : 0;
  this.vertical = _.direction > 150 && _.direction < 210 || _.direction > 330 && _.direction < 390 || _.direction > -30 && _.direction < 30;
  this.horizontal = _.direction > 60 && _.direction < 120 || _.direction > 240 && _.direction < 300;
};
Sparticle.prototype.init = function() {
  var _ = this.settings;
  var canvas = this.canvas;
  this.alpha = 0;
  if (_.speed > 0 || _.alphaSpeed === 0) {
    this.alpha = random(_.minAlpha, _.maxAlpha);
  }
  if (_.bounce) {
    this.px = round(random(2, canvas.width - this.size - 2));
    this.py = round(random(2, canvas.height - this.size - 2));
  } else {
    this.px = round(random(-this.size * 2, canvas.width + this.size));
    this.py = round(random(-this.size * 2, canvas.height + this.size));
  }
};
Sparticle.prototype.reset = function() {
  this.setup();
  if (this.py < 0) {
    this.py = this.canvas.height + this.size * 2;
  } else if (this.py > this.canvas.height) {
    this.py = 0 - this.size * 2;
  }
  if (this.px < 0) {
    this.px = this.canvas.width + this.size * 2;
  } else if (this.px > this.canvas.width) {
    this.px = 0 - this.size * 2;
  }
};
Sparticle.prototype.bounce = function() {
  var _ = this.settings;
  var dir = _.direction;
  if (this.py <= 0 || this.py + this.size >= this.canvas.height) {
    this.dy = -this.dy;
    if (this.horizontal) {
      this.dd = -this.dd;
    }
  }
  if (this.px <= 0 || this.px + this.size >= this.canvas.width) {
    this.dx = -this.dx;
    if (this.vertical) {
      this.dd = -this.dd;
    }
  }
};
Sparticle.prototype.isOffCanvas = function() {
  var topleft = 0 - this.size * 2;
  var bottom = this.canvas.height + this.size * 2;
  var right = this.canvas.width + this.size * 2;
  return this.px < topleft || this.px > right || this.py < topleft || this.py > bottom;
};
Sparticle.prototype.isTouchingEdge = function() {
  var topleft = 0;
  var bottom = this.canvas.height - this.size;
  var right = this.canvas.width - this.size;
  return this.px < topleft || this.px > right || this.py < topleft || this.py > bottom;
};
Sparticle.prototype.getColor = function() {
  if (this.settings.color === "random") {
    return randomArray(this.colors);
  } else if (Array.isArray(this.settings.color)) {
    return randomArray(this.settings.color);
  } else {
    return this.settings.color;
  }
};
Sparticle.prototype.getShape = function() {
  if (this.settings.shape === "random") {
    return randomArray(this.shapes);
  } else if (Array.isArray(this.settings.shape)) {
    return randomArray(this.settings.shape);
  } else {
    return this.settings.shape;
  }
};
Sparticle.prototype.getImage = function() {
  if (Array.isArray(this.settings.imageUrl)) {
    return randomArray(this.settings.imageUrl);
  } else {
    return this.settings.imageUrl;
  }
};
Sparticle.prototype.getStyle = function() {
  return randomArray(this.styles);
};
Sparticle.prototype.getDelta = function() {
  var baseDelta = this.settings.speed * 0.1;
  if (this.settings.speed && this.settings.parallax) {
    return baseDelta + this.size * this.settings.parallax / 50;
  } else {
    return baseDelta;
  }
};
Sparticle.prototype.getDeltaVariance = function() {
  var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var s = this.settings.speed || 10;
  if (v > 0) {
    return random(-v, v) * s / 100;
  } else {
    return 0;
  }
};
Sparticle.prototype.getDeltaX = function() {
  var d = this.getDelta();
  var dv = this.getDeltaVariance(this.settings.xVariance);
  return cartesian(this.settings.direction)[0] * d + dv;
};
Sparticle.prototype.getDeltaY = function() {
  var d = this.getDelta();
  var dv = this.getDeltaVariance(this.settings.yVariance);
  return cartesian(this.settings.direction)[1] * d + dv;
};
Sparticle.prototype.getAlphaDelta = function() {
  var variance = this.settings.alphaVariance;
  var a = random(1, variance + 1);
  if (roll(1 / 2)) {
    a = -a;
  }
  return a;
};
Sparticle.prototype.getDriftDelta = function() {
  if (!this.settings.drift) {
    return 0;
  } else {
    return random(this.settings.drift - this.settings.drift / 2, this.settings.drift + this.settings.drift / 2);
  }
};
Sparticle.prototype.getRotationDelta = function() {
  var r = 0;
  if (this.settings.rotate && this.settings.rotation) {
    r = radian(random(0.5, 1.5) * this.settings.rotation);
    if (roll(1 / 2)) {
      r = -r;
    }
  }
  return r;
};
Sparticle.prototype.update = function() {
  this.frame += 1;
  this.updatePosition();
  this.updateAlpha();
  return this;
};
Sparticle.prototype.updateAlpha = function() {
  if (this.settings.alphaSpeed > 0) {
    if (this.settings.twinkle) {
      this.alpha = this.updateTwinkle();
    } else {
      this.alpha = this.updateFade();
    }
  }
  return this.alpha;
};
Sparticle.prototype.updateFade = function() {
  var tick = this.da / 1e3 * this.settings.alphaSpeed * 0.5;
  var alpha = this.alpha + tick;
  var over = this.da > 0 && alpha > this.settings.maxAlpha;
  var under = this.da < 0 && alpha < this.settings.minAlpha;
  if (over || under) {
    this.da = -this.da;
    alpha = this.settings.maxAlpha;
    if (under) {
      alpha = this.settings.minAlpha;
    }
  }
  return alpha;
};
Sparticle.prototype.updateTwinkle = function() {
  var alpha = this.alpha;
  var delta = Math.abs(this.da);
  var over = alpha > this.settings.maxAlpha;
  var under = alpha < this.settings.minAlpha;
  var tick = delta / 1e3 * this.settings.alphaSpeed * 0.5;
  var flickerOn = roll(1 / 30);
  var flickerOff = roll(1 / 30);
  if (this.resettingTwinkle) {
    alpha += tick * 5;
  } else if (flickerOn) {
    alpha += tick * 50;
  } else if (flickerOff) {
    alpha -= tick * 25;
  } else {
    alpha -= tick;
  }
  if (under) {
    this.resettingTwinkle = true;
    alpha = this.settings.minAlpha;
  } else if (over) {
    this.resettingTwinkle = false;
    alpha = this.settings.maxAlpha;
  }
  return alpha;
};
Sparticle.prototype.updatePosition = function() {
  if (this.settings.bounce && this.isTouchingEdge()) {
    this.bounce();
  } else if (this.isOffCanvas()) {
    this.reset();
    return;
  }
  this.px += this.dx;
  this.py += this.dy;
  this.updateDrift();
  this.updateRotation();
};
Sparticle.prototype.updateRotation = function() {
  if (this.settings.rotate && this.settings.rotation) {
    this.rotation += this.dr;
  }
};
Sparticle.prototype.updateDrift = function() {
  var _ = this.settings;
  var dir = _.direction;
  if (_.drift && _.speed) {
    if (this.vertical) {
      this.px += cartesian(this.frame + this.frameoffset)[0] * this.dd / (this.getDelta() * 15);
    } else if (this.horizontal) {
      this.py += cartesian(this.frame + this.frameoffset)[1] * this.dd / (this.getDelta() * 15);
    }
  }
};
Sparticle.prototype.render = function(canvasses) {
  var particleCanvas;
  if (this.shape !== "image") {
    particleCanvas = canvasses[this.color][this.shape][this.style];
  } else {
    particleCanvas = canvasses[this.color][this.shape][this.image];
  }
  var canvasSize = particleCanvas.width;
  var scale = this.size / canvasSize;
  var px = this.px / scale;
  var py = this.py / scale;
  this.ctx.globalAlpha = clamp(this.alpha, 0, 1);
  this.renderRotate();
  this.ctx.transform(scale, 0, 0, scale, 0, 0);
  this.ctx.drawImage(particleCanvas, 0, 0, canvasSize, canvasSize, px, py, canvasSize, canvasSize);
  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
  return this;
};
Sparticle.prototype.renderRotate = function() {
  if (this.shape !== "circle" && this.settings.rotate) {
    var centerX = this.px + this.size / 2;
    var centerY = this.py + this.size / 2;
    this.ctx.translate(centerX, centerY);
    this.ctx.rotate(this.rotation);
    this.ctx.translate(-centerX, -centerY);
  }
};
var Sparticles = function Sparticles2(node, options, width, height) {
  if (arguments.length >= 1 && !(arguments[0] instanceof HTMLElement)) {
    options = arguments[0];
    width = arguments[1];
    height = arguments[2];
    node = void 0;
  }
  if (width && !height) {
    height = width;
  }
  var defaults = {
    alphaSpeed: 10,
    alphaVariance: 1,
    bounce: false,
    color: "random",
    randomColor: randomHsl,
    randomColorCount: 3,
    composition: "source-over",
    count: 50,
    direction: 180,
    drift: 1,
    glow: 0,
    imageUrl: "",
    maxAlpha: 1,
    maxSize: 10,
    minAlpha: 0,
    minSize: 1,
    parallax: 1,
    rotate: true,
    rotation: 1,
    shape: "circle",
    speed: 10,
    style: "fill",
    twinkle: false,
    xVariance: 2,
    yVariance: 2
  };
  this.el = node || document.body;
  this.settings = _objectSpread2(_objectSpread2({}, defaults), options);
  this.resizable = !width && !height;
  this.width = this.resizable ? this.el.clientWidth : width;
  this.height = this.resizable ? this.el.clientHeight : height;
  this.init = function() {
    var _this = this;
    this.sparticles = [];
    this.colors = this.getColorArray();
    this.shapes = this.getShapeArray();
    this.styles = this.getStyleArray();
    this.imageUrls = this.getImageArray();
    this.setupMainCanvas();
    this.setupOffscreenCanvasses(function() {
      _this.createSparticles();
      _this.start();
    });
    window.addEventListener("resize", this);
    return this;
  };
  this.handleEvent = function(event) {
    var _this2 = this;
    if (event.type === "resize") {
      clearTimeout(this.resizeTimer);
      this.resizeTimer = setTimeout(function() {
        if (_this2.resizable) {
          _this2.width = _this2.el.clientWidth;
          _this2.height = _this2.el.clientHeight;
          _this2.setCanvasSize().resetSparticles();
        }
      }, 200);
    }
  };
  this.start = function() {
    var me = this;
    if (!this.loop) {
      this.loop = new AnimationFrame(function(t) {
        me.drawFrame(t);
      });
    }
    this.loop.start();
    return this;
  };
  this.stop = function() {
    this.loop.stop();
    return this;
  };
  this.destroy = function() {
    this.stop();
    this.el.removeChild(this.canvas);
    window.removeEventListener("resize", this);
    for (var prop in this) {
      if (this.hasOwnProperty(prop)) {
        delete this[prop];
      }
    }
    return this;
  };
  this.setCanvasSize = function(width2, height2) {
    if (width2) {
      this.resizable = false;
    }
    this.width = width2 || this.width;
    this.height = height2 || this.height;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    return this;
  };
  this.resetSparticles = this.createSparticles = function() {
    this.sparticles = [];
    this.ctx.globalCompositeOperation = this.settings.composition;
    for (var i = 0; i < this.settings.count; i++) {
      this.sparticles.push(new Sparticle(this, i));
    }
    this.sort();
    return this.sparticles;
  };
  this.sort = function() {
    if (this.settings.parallax) {
      this.sparticles.sort(function(a, b) {
        return a.size - b.size;
      });
    }
  };
  return this.init();
};
Sparticles.prototype.getColorArray = function() {
  var colors = Array.isArray(this.settings.color) ? this.settings.color : [this.settings.color];
  var isRandom = colors.some(function(c) {
    return c === "random";
  });
  if (isRandom) {
    for (var i = 0; i < this.settings.randomColorCount; i++) {
      colors[i] = this.settings.randomColor(i, this.settings.randomColorCount);
    }
  }
  return colors;
};
Sparticles.prototype.getShapeArray = function() {
  var shapes = Array.isArray(this.settings.shape) ? this.settings.shape : [this.settings.shape];
  var isRandom = shapes.some(function(c) {
    return c === "random";
  });
  if (isRandom) {
    shapes = ["square", "circle", "triangle"];
  }
  return shapes;
};
Sparticles.prototype.getImageArray = function() {
  return Array.isArray(this.settings.imageUrl) ? this.settings.imageUrl : [this.settings.imageUrl];
};
Sparticles.prototype.getStyleArray = function() {
  var styles = this.settings.style;
  if (styles !== "fill" && styles !== "stroke") {
    styles = ["fill", "stroke"];
  } else {
    styles = [styles];
  }
  return styles;
};
Sparticles.prototype.setupMainCanvas = function() {
  this.canvas = document.createElement("canvas");
  this.canvas.setAttribute("class", "sparticles");
  this.ctx = this.canvas.getContext("2d");
  this.setCanvasSize();
  this.el.appendChild(this.canvas);
  return this.canvas;
};
Sparticles.prototype.setupOffscreenCanvasses = function(callback) {
  var _this3 = this;
  var colors = this.colors.filter(function(item, index) {
    return _this3.colors.indexOf(item) === index;
  });
  var shapes = this.shapes.filter(function(item, index) {
    return _this3.shapes.indexOf(item) === index;
  });
  var styles = this.styles.filter(function(item, index) {
    return _this3.styles.indexOf(item) === index;
  });
  var imageUrls = this.imageUrls.filter(function(item, index) {
    return _this3.imageUrls.indexOf(item) === index;
  });
  var imageCount = colors.length * imageUrls.length;
  var canvasCount = colors.length * shapes.length * styles.length;
  var imagesLoaded = 0;
  var canvassesCreated = 0;
  this.canvasses = this.canvasses || {};
  colors.forEach(function(color) {
    _this3.canvasses[color] = _this3.canvasses[color] || {};
    shapes.forEach(function(shape) {
      _this3.canvasses[color][shape] = _this3.canvasses[color][shape] || {};
      if (shape === "image") {
        imageUrls.forEach(function(imageUrl, i) {
          var image = new Image();
          var imageCanvas = document.createElement("canvas");
          _this3.canvasses[color][shape][imageUrl] = imageCanvas;
          image.onload = function() {
            imagesLoaded++;
            _this3.drawOffscreenCanvasForImage(image, color, imageCanvas);
            if (callback && imagesLoaded === imageCount) {
              callback();
            }
          };
          image.onerror = function() {
            console.error("failed to load source image: ", imageUrl);
          };
          image.src = imageUrl;
        });
      } else {
        styles.forEach(function(style) {
          var canvas = document.createElement("canvas");
          _this3.canvasses[color][shape][style] = canvas;
          canvassesCreated++;
          _this3.drawOffscreenCanvas(shape, style, color, canvas);
          if (callback && canvassesCreated === canvasCount) {
            callback();
          }
        });
      }
    });
  });
};
Sparticles.prototype.getGlowSize = function(size) {
  return this.settings.glow;
};
Sparticles.prototype.getLineSize = function(size) {
  return clamp(size / 20, 1, 5);
};
Sparticles.prototype.getOffscreenCanvasSize = function() {
  return clamp(this.settings.maxSize, this.settings.minSize, this.settings.maxSize);
};
Sparticles.prototype.renderStyle = function(ctx, color, lineSize, style) {
  if (style === "fill") {
    ctx.fillStyle = color;
  } else {
    ctx.lineWidth = lineSize;
    ctx.strokeStyle = color;
  }
};
Sparticles.prototype.renderGlow = function(ctx, color, size) {
  var glowSize = this.getGlowSize(size) / 2;
  ctx.shadowColor = color;
  ctx.shadowBlur = glowSize;
};
Sparticles.prototype.renderColor = function(ctx, style, path) {
  if (style === "fill") {
    if (path) {
      ctx.fill(path);
    } else {
      ctx.fill();
    }
  } else {
    if (path) {
      ctx.stroke(path);
    } else {
      ctx.stroke();
    }
  }
};
Sparticles.prototype.drawOffscreenCanvas = function(shape, style, color, canvas) {
  return this.offScreenCanvas[shape].call(this, style, color, canvas);
};
Sparticles.prototype.offScreenCanvas = {};
Sparticles.prototype.offScreenCanvas.circle = function(style, color, canvas) {
  var ctx = canvas.getContext("2d");
  var size = this.getOffscreenCanvasSize();
  var lineSize = this.getLineSize(size);
  var glowSize = this.getGlowSize(size);
  var canvasSize = size + lineSize * 2 + glowSize;
  var shapeSize = style === "stroke" ? size - lineSize : size;
  canvas.width = canvasSize;
  canvas.height = canvasSize;
  this.renderGlow(ctx, color, size);
  this.renderStyle(ctx, color, lineSize, style);
  ctx.beginPath();
  ctx.ellipse(canvasSize / 2, canvasSize / 2, shapeSize / 2, shapeSize / 2, 0, 0, 360);
  this.renderColor(ctx, style);
  return canvas;
};
Sparticles.prototype.offScreenCanvas.square = function(style, color, canvas) {
  var ctx = canvas.getContext("2d");
  var size = this.getOffscreenCanvasSize();
  var lineSize = this.getLineSize(size);
  var glowSize = this.getGlowSize(size);
  var canvasSize = size + lineSize * 2 + glowSize;
  var shapeSize = style === "stroke" ? size - lineSize : size;
  canvas.width = canvasSize;
  canvas.height = canvasSize;
  this.renderGlow(ctx, color, size);
  this.renderStyle(ctx, color, lineSize, style);
  ctx.beginPath();
  ctx.rect(canvasSize / 2 - shapeSize / 2, canvasSize / 2 - shapeSize / 2, shapeSize, shapeSize);
  this.renderColor(ctx, style);
  return canvas;
};
Sparticles.prototype.offScreenCanvas.line = function(style, color, canvas) {
  var ctx = canvas.getContext("2d");
  var size = this.getOffscreenCanvasSize() * 1.5;
  var lineSize = this.getLineSize(size);
  var glowSize = this.getGlowSize(size);
  var canvasSize = size + lineSize * 2 + glowSize;
  var startx = canvasSize / 2 - size / 2;
  var starty = canvasSize / 2 - size / 2;
  canvas.width = canvasSize;
  canvas.height = canvasSize;
  this.renderGlow(ctx, color, size);
  ctx.lineWidth = lineSize;
  ctx.strokeStyle = color;
  ctx.beginPath();
  ctx.moveTo(startx, starty);
  ctx.lineTo(startx + size, starty + size);
  ctx.stroke();
  ctx.closePath();
  return canvas;
};
Sparticles.prototype.offScreenCanvas.triangle = function(style, color, canvas) {
  var ctx = canvas.getContext("2d");
  var size = this.getOffscreenCanvasSize();
  var lineSize = this.getLineSize(size);
  var glowSize = this.getGlowSize(size);
  var canvasSize = size + lineSize * 2 + glowSize;
  var shapeSize = style === "stroke" ? size - lineSize : size;
  var height = shapeSize * (Math.sqrt(3) / 2);
  var startx = canvasSize / 2;
  var starty = canvasSize / 2 - shapeSize / 2;
  canvas.width = canvasSize;
  canvas.height = canvasSize;
  this.renderGlow(ctx, color, size);
  this.renderStyle(ctx, color, lineSize, style);
  ctx.beginPath();
  ctx.moveTo(startx, starty);
  ctx.lineTo(startx - shapeSize / 2, starty + height);
  ctx.lineTo(startx + shapeSize / 2, starty + height);
  ctx.closePath();
  this.renderColor(ctx, style);
  return canvas;
};
Sparticles.prototype.offScreenCanvas.diamond = function(style, color, canvas) {
  var pathSize = 100;
  var path = new Path2D("M43,83.74,48.63,99a1.46,1.46,0,0,0,2.74,0L57,83.74A45.09,45.09,0,0,1,83.74,57L99,51.37a1.46,1.46,0,0,0,0-2.74L83.74,43A45.11,45.11,0,0,1,57,16.26L51.37,1a1.46,1.46,0,0,0-2.74,0L43,16.26A45.11,45.11,0,0,1,16.26,43L1,48.63a1.46,1.46,0,0,0,0,2.74L16.26,57A45.09,45.09,0,0,1,43,83.74Z");
  var ctx = canvas.getContext("2d");
  var size = this.getOffscreenCanvasSize();
  var lineSize = this.getLineSize(size);
  var glowSize = this.getGlowSize(size);
  var canvasSize = size + lineSize * 2 + glowSize;
  var scale = canvasSize / ((pathSize + glowSize) * 1.1);
  canvas.width = canvasSize;
  canvas.height = canvasSize;
  this.renderGlow(ctx, color, size);
  this.renderStyle(ctx, color, lineSize / scale, style);
  ctx.scale(scale, scale);
  ctx.translate(pathSize * 0.05 + glowSize * 0.5, pathSize * 0.05 + glowSize * 0.5);
  this.renderColor(ctx, style, path);
  return canvas;
};
Sparticles.prototype.offScreenCanvas.star = function(style, color, canvas) {
  var pathSize = 100;
  var path = new Path2D("M99.86,36.45a2.94,2.94,0,0,0-2.37-2l-31-4.54L52.63,1.64a2.93,2.93,0,0,0-5.26,0L33.51,29.91l-31,4.54a3,3,0,0,0-2.37,2,3,3,0,0,0,.74,3l22.44,22L18,92.55A2.94,2.94,0,0,0,20.91,96a2.86,2.86,0,0,0,1.36-.34L50,81,77.73,95.66a2.91,2.91,0,0,0,3.08-.22A3,3,0,0,0,82,92.55l-5.3-31.07,22.44-22A3,3,0,0,0,99.86,36.45Z");
  var ctx = canvas.getContext("2d");
  var size = this.getOffscreenCanvasSize();
  var lineSize = this.getLineSize(size);
  var glowSize = this.getGlowSize(size);
  var canvasSize = size + lineSize * 2 + glowSize;
  var scale = canvasSize / ((pathSize + glowSize) * 1.1);
  canvas.width = canvasSize;
  canvas.height = canvasSize;
  ctx.scale(scale, scale);
  this.renderGlow(ctx, color, size);
  this.renderStyle(ctx, color, lineSize / scale, style);
  ctx.translate(pathSize * 0.05 + glowSize * 0.5, pathSize * 0.05 + glowSize * 0.5);
  this.renderColor(ctx, style, path);
  return canvas;
};
Sparticles.prototype.drawOffscreenCanvasForImage = function(image, color, canvas) {
  var size = image.width;
  var ctx = canvas.getContext("2d");
  canvas.width = size;
  canvas.height = size;
  ctx.drawImage(image, 0, 0, size, size, 0, 0, size, size);
  ctx.globalCompositeOperation = "source-atop";
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, size, size);
  return canvas;
};
Sparticles.prototype.drawFrame = function() {
  this.ctx.clearRect(0, 0, this.width, this.height);
  for (var i = 0; i < this.sparticles.length; i++) {
    var sparticle = this.sparticles[i];
    sparticle.update().render(this.canvasses);
  }
  this.sort();
  return this.sparticles;
};
var sparticles_default = Sparticles;
export {
  sparticles_default as default
};
/*! Bundled license information:

sparticles/dist/sparticles.mjs:
  (**!
   * Sparticles - Lightweight, High Performance Particles in Canvas
   * @version 1.3.1
   * @license MPL-2.0
   * @author simeydotme <simey.me@gmail.com>
   * @website http://sparticlesjs.dev
   * @repository https://github.com/simeydotme/sparticles.git
   *)
*/
//# sourceMappingURL=sparticles.js.map
