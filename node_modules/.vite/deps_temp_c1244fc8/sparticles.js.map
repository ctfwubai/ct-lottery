{
  "version": 3,
  "sources": ["../../sparticles/dist/sparticles.mjs"],
  "sourcesContent": ["/**!\n * Sparticles - Lightweight, High Performance Particles in Canvas\n * @version 1.3.1\n * @license MPL-2.0\n * @author simeydotme <simey.me@gmail.com>\n * @website http://sparticlesjs.dev\n * @repository https://github.com/simeydotme/sparticles.git\n */\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n/**\n * Limited Animation Frame method, to allow running\n * a given handler at the maximum desired frame rate.\n * inspired from https://gist.github.com/addyosmani/5434533\n * @param {Function} handler method to execute upon every frame\n * @param {Number} fps how many frames to render every second\n */\nvar AnimationFrame = function AnimationFrame() {\n  var handler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n  var fps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;\n  this.fps = fps;\n  this.handler = handler;\n  var renderId = 0;\n  /**\n   * begin the animation loop which is assigned\n   * to the instance in the constructor\n   */\n\n  this.start = function () {\n    var _this = this;\n\n    if (!this.started) {\n      var then = performance.now();\n      var interval = 1000 / this.fps;\n      var tolerance = 0;\n\n      var loop = function loop(now) {\n        var delta = now - then;\n        renderId = requestAnimationFrame(loop);\n\n        if (delta >= interval - tolerance) {\n          _this.handler(delta);\n\n          then = now - delta % interval;\n        }\n      };\n\n      renderId = requestAnimationFrame(loop);\n      this.started = true;\n    }\n  };\n  /**\n   * stop the currently running animation loop\n   */\n\n\n  this.stop = function () {\n    cancelAnimationFrame(renderId);\n    this.started = false;\n  };\n};\n\n/**\n * return the cartesian x/y delta value from a degree\n * eg: 90 (→) = [1,0]\n * @param {Number} angle angle in degrees\n * @returns {Number[]} cartesian delta values\n */\nvar cartesian = function cartesian(angle) {\n  return [Math.cos(radian(angle - 90)), Math.sin(radian(angle - 90))];\n};\n/**\n * clamp the input number to the min/max values\n * @param {Number} value value to clamp between min and max\n * @param {Number} min minimum value possible\n * @param {Number} max maximum value possible\n * @returns {Number} the input num clamped between min/max\n */\n\nvar clamp = function clamp(value) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return Math.max(min, Math.min(max, value));\n};\n/**\n * return the radian equivalent to a degree value\n * @param {Number} angle angle in degrees\n * @returns {Number} radian equivalent\n */\n\nvar radian = function radian(angle) {\n  return angle * Math.PI / 180;\n};\n/**\n * return random number between a min and max value\n * @param {Number} min minimum value\n * @param {Number} max maximum value\n * @param {Boolean} rounded should the result be rounded\n * @returns {Number} a random number between min and max\n */\n\nvar random = function random() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.random();\n\n  if (max <= min) {\n    value = min;\n  } else if ((min !== 0 || max !== 1) && max > min) {\n    value = value * (max - min) + min;\n  }\n\n  return value;\n};\n/**\n * return a random value from an array\n * @param {Array} array an array to get random value from\n * @returns {*} random value from array\n */\n\nvar randomArray = function randomArray(array) {\n  return array[Math.floor(random(0, array.length))];\n};\n/**\n * return a random HSL colour string for use in random color effect\n * @returns {String} \"hsl(100,100,80)\"\n */\n\nvar randomHsl = function randomHsl() {\n  var h = round(random(0, 360));\n  var s = round(random(90, 100));\n  var l = round(random(45, 85));\n  return \"hsl(\".concat(h, \",\").concat(s, \"%,\").concat(l, \"%)\");\n};\n/**\n * return a boolean to pass a dice roll\n * @param {Number} odds a fraction to use as the probability, can be supplied as \"1/2\"\n * @returns {Boolean}\n */\n\nvar roll = function roll(odds) {\n  return odds > random();\n};\n/**\n * round a number to the nearest integer value\n * @param {Number} value value to round to the nearest integer\n * @returns {Number} nearest integer\n */\n\nvar round = function round(value) {\n  return 0.5 + value | 0;\n};\n\n/**\n * Sparticle Constructor;\n * creates an individual particle for use in the Sparticles() class\n * @param {Object} parent - the parent Sparticles() instance this belongs to\n * @returns {Object} - reference to a new Sparticle instance\n */\n\nvar Sparticle = function Sparticle(parent) {\n  if (parent) {\n    this.canvas = parent.canvas;\n    this.settings = parent.settings;\n    this.colors = parent.colors;\n    this.shapes = parent.shapes;\n    this.images = parent.images;\n    this.styles = parent.styles;\n    this.ctx = parent.canvas.getContext(\"2d\");\n    this.setup();\n    this.init();\n  } else {\n    console.warn(\"Invalid parameters given to Sparticle()\", arguments);\n  }\n\n  return this;\n};\n/**\n * set up the particle with some random values\n * before it is initialised on the canvas\n * these values will randomize when the particle goes offscreen\n */\n\nSparticle.prototype.setup = function () {\n  var _ = this.settings;\n  this.frame = 0;\n  this.frameoffset = round(random(0, 360));\n  this.size = round(random(_.minSize, _.maxSize));\n  this.da = this.getAlphaDelta();\n  this.dx = this.getDeltaX();\n  this.dy = this.getDeltaY();\n  this.dd = this.getDriftDelta();\n  this.dr = this.getRotationDelta();\n  this.color = this.getColor();\n  this.shape = this.getShape();\n  this.image = this.getImage();\n  this.style = this.getStyle();\n  this.rotation = _.rotate ? radian(random(0, 360)) : 0;\n  this.vertical = _.direction > 150 && _.direction < 210 || _.direction > 330 && _.direction < 390 || _.direction > -30 && _.direction < 30;\n  this.horizontal = _.direction > 60 && _.direction < 120 || _.direction > 240 && _.direction < 300;\n};\n/**\n * initialise a particle with the default values from\n * the Sparticles instance settings.\n * these values do not change when the particle goes offscreen\n */\n\n\nSparticle.prototype.init = function () {\n  var _ = this.settings;\n  var canvas = this.canvas;\n  this.alpha = 0;\n\n  if (_.speed > 0 || _.alphaSpeed === 0) {\n    this.alpha = random(_.minAlpha, _.maxAlpha);\n  }\n\n  if (_.bounce) {\n    this.px = round(random(2, canvas.width - this.size - 2));\n    this.py = round(random(2, canvas.height - this.size - 2));\n  } else {\n    this.px = round(random(-this.size * 2, canvas.width + this.size));\n    this.py = round(random(-this.size * 2, canvas.height + this.size));\n  }\n};\n/**\n * reset the particle after it has gone off canvas.\n * this should be better than popping it from the array\n * and creating a new particle instance.\n */\n\n\nSparticle.prototype.reset = function () {\n  // give the particle a new set of initial values\n  this.setup(); // set the particle's Y position\n\n  if (this.py < 0) {\n    this.py = this.canvas.height + this.size * 2;\n  } else if (this.py > this.canvas.height) {\n    this.py = 0 - this.size * 2;\n  } // set the particle's X position\n\n\n  if (this.px < 0) {\n    this.px = this.canvas.width + this.size * 2;\n  } else if (this.px > this.canvas.width) {\n    this.px = 0 - this.size * 2;\n  }\n};\n/**\n * bounce the particle off the edge of canvas\n * when it has touched\n */\n\n\nSparticle.prototype.bounce = function () {\n  var _ = this.settings;\n  var dir = _.direction; // reverse the particle's Y position\n\n  if (this.py <= 0 || this.py + this.size >= this.canvas.height) {\n    this.dy = -this.dy;\n\n    if (this.horizontal) {\n      this.dd = -this.dd;\n    }\n  } // reverse the particle's X position\n\n\n  if (this.px <= 0 || this.px + this.size >= this.canvas.width) {\n    this.dx = -this.dx;\n\n    if (this.vertical) {\n      this.dd = -this.dd;\n    }\n  }\n};\n/**\n * check if the particle is off the canvas based\n * on it's current position\n * @returns {Boolean} is the particle completely off canvas\n */\n\n\nSparticle.prototype.isOffCanvas = function () {\n  var topleft = 0 - this.size * 2;\n  var bottom = this.canvas.height + this.size * 2;\n  var right = this.canvas.width + this.size * 2;\n  return this.px < topleft || this.px > right || this.py < topleft || this.py > bottom;\n};\n/**\n * check if the particle is touching the canvas edge\n * @returns {Boolean} is the particle touching edge\n */\n\n\nSparticle.prototype.isTouchingEdge = function () {\n  var topleft = 0;\n  var bottom = this.canvas.height - this.size;\n  var right = this.canvas.width - this.size;\n  return this.px < topleft || this.px > right || this.py < topleft || this.py > bottom;\n};\n/**\n * get a random color for the particle from the\n * array of colors set in the options object\n * @returns {String} - random color from color array\n */\n\n\nSparticle.prototype.getColor = function () {\n  if (this.settings.color === \"random\") {\n    return randomArray(this.colors);\n  } else if (Array.isArray(this.settings.color)) {\n    return randomArray(this.settings.color);\n  } else {\n    return this.settings.color;\n  }\n};\n/**\n * get a random shape for the particle from the\n * array of shapes set in the options object\n * @returns {String} - random shape from shape array\n */\n\n\nSparticle.prototype.getShape = function () {\n  if (this.settings.shape === \"random\") {\n    return randomArray(this.shapes);\n  } else if (Array.isArray(this.settings.shape)) {\n    return randomArray(this.settings.shape);\n  } else {\n    return this.settings.shape;\n  }\n};\n/**\n * get the image for the particle from the array\n * of possible image urls\n * @returns {String} - random imageUrl from imageUrl array\n */\n\n\nSparticle.prototype.getImage = function () {\n  if (Array.isArray(this.settings.imageUrl)) {\n    return randomArray(this.settings.imageUrl);\n  } else {\n    return this.settings.imageUrl;\n  }\n};\n/**\n * get the style of the particle, either \"fill\" or \"stroke\"\n * depending on the settings as fill/stroke/both\n * @returns {String} - either \"fill\" or \"stroke\"\n */\n\n\nSparticle.prototype.getStyle = function () {\n  return randomArray(this.styles);\n};\n/**\n * get a random delta (velocity) for the particle\n * based on the speed, and the parallax value (if applicable)\n * @returns {Number} - the velocity to be applied to the particle\n */\n\n\nSparticle.prototype.getDelta = function () {\n  var baseDelta = this.settings.speed * 0.1;\n\n  if (this.settings.speed && this.settings.parallax) {\n    return baseDelta + this.size * this.settings.parallax / 50;\n  } else {\n    return baseDelta;\n  }\n};\n/**\n * get a random variable speed for use as a multiplier,\n * based on the values given in the settings object, this\n * can be positive or negative\n * @returns {Number} - a variable delta speed\n */\n\n\nSparticle.prototype.getDeltaVariance = function () {\n  var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var s = this.settings.speed || 10;\n\n  if (v > 0) {\n    return random(-v, v) * s / 100;\n  } else {\n    return 0;\n  }\n};\n/**\n * get a random delta on the X axis, taking in to account\n * the variance range in the settings object and the particle's\n * direction as a multiplier\n * @returns {Number} - the X delta to be applied to particle\n */\n\n\nSparticle.prototype.getDeltaX = function () {\n  var d = this.getDelta();\n  var dv = this.getDeltaVariance(this.settings.xVariance);\n  return cartesian(this.settings.direction)[0] * d + dv;\n};\n/**\n * get a random delta on the Y axis, taking in to account\n * the variance range in the settings object and the particle's\n * direction as a multiplier\n * @returns {Number} - the Y delta to be applied to particle\n */\n\n\nSparticle.prototype.getDeltaY = function () {\n  var d = this.getDelta();\n  var dv = this.getDeltaVariance(this.settings.yVariance);\n  return cartesian(this.settings.direction)[1] * d + dv;\n};\n/**\n * get a random delta for the alpha change over time from\n * between a positive and negative alpha variance value\n * @returns {Number} - the alpha delta to be applied to particle\n */\n\n\nSparticle.prototype.getAlphaDelta = function () {\n  var variance = this.settings.alphaVariance;\n  var a = random(1, variance + 1);\n\n  if (roll(1 / 2)) {\n    a = -a;\n  }\n\n  return a;\n};\n/**\n * return a random drift value either positive or negative\n * @returns {Number} - the drift value\n */\n\n\nSparticle.prototype.getDriftDelta = function () {\n  if (!this.settings.drift) {\n    return 0;\n  } else {\n    return random(this.settings.drift - this.settings.drift / 2, this.settings.drift + this.settings.drift / 2);\n  }\n};\n/**\n * return a random rotation value either positive or negative\n * @returns {Number} - the rotation value\n */\n\n\nSparticle.prototype.getRotationDelta = function () {\n  var r = 0;\n\n  if (this.settings.rotate && this.settings.rotation) {\n    r = radian(random(0.5, 1.5) * this.settings.rotation);\n\n    if (roll(1 / 2)) {\n      r = -r;\n    }\n  }\n\n  return r;\n};\n/**\n * progress the particle's frame number, as well\n * as the internal values for both the particle's\n * position and the particle's alpha.\n * @returns {Object} - reference to the current Sparticle instance\n */\n\n\nSparticle.prototype.update = function () {\n  this.frame += 1;\n  this.updatePosition();\n  this.updateAlpha();\n  return this;\n};\n/**\n * progress the particle's alpha value depending on the\n * alphaSpeed and the twinkle setting\n * @returns {Number} - new alpha value of the particle\n */\n\n\nSparticle.prototype.updateAlpha = function () {\n  if (this.settings.alphaSpeed > 0) {\n    if (this.settings.twinkle) {\n      this.alpha = this.updateTwinkle();\n    } else {\n      this.alpha = this.updateFade();\n    }\n  }\n\n  return this.alpha;\n};\n/**\n * progress the particle's alpha value according to\n * the fading effect\n * @returns {Number} - new alpha value of the particle\n */\n\n\nSparticle.prototype.updateFade = function () {\n  var tick = this.da / 1000 * this.settings.alphaSpeed * 0.5;\n  var alpha = this.alpha + tick;\n  var over = this.da > 0 && alpha > this.settings.maxAlpha;\n  var under = this.da < 0 && alpha < this.settings.minAlpha; // if the alpha is over or under the min or max values,\n  // then we reverse the delta so that it can increase or\n  // decrease in opacity in the opposite direction\n\n  if (over || under) {\n    this.da = -this.da;\n    alpha = this.settings.maxAlpha;\n\n    if (under) {\n      alpha = this.settings.minAlpha;\n    }\n  }\n\n  return alpha;\n};\n/**\n * progress the particle's alpha value according to\n * the twinkle effect\n * @returns {Number} - new alpha value of the particle\n */\n\n\nSparticle.prototype.updateTwinkle = function () {\n  var alpha = this.alpha;\n  var delta = Math.abs(this.da);\n  var over = alpha > this.settings.maxAlpha;\n  var under = alpha < this.settings.minAlpha;\n  var tick = delta / 1000 * this.settings.alphaSpeed * 0.5;\n  var flickerOn = roll(1 / 30);\n  var flickerOff = roll(1 / 30); // if the particle is resetting the twinkle effect, then\n  // we simply want to quickly get back to max alpha\n  // over a short period of time, otherwise just advance the tick\n\n  if (this.resettingTwinkle) {\n    alpha += tick * 5;\n  } else if (flickerOn) {\n    alpha += tick * 50;\n  } else if (flickerOff) {\n    alpha -= tick * 25;\n  } else {\n    alpha -= tick;\n  } // once the alpha is under the min alpha value, then we need\n  // to set the twinkle effect to reset, and once it is over\n  // the max alpha, we stop resetting.\n\n\n  if (under) {\n    this.resettingTwinkle = true;\n    alpha = this.settings.minAlpha;\n  } else if (over) {\n    this.resettingTwinkle = false;\n    alpha = this.settings.maxAlpha;\n  }\n\n  return alpha;\n};\n/**\n * progress the particle's position values, rotation and drift\n * according to the settings given\n */\n\n\nSparticle.prototype.updatePosition = function () {\n  if (this.settings.bounce && this.isTouchingEdge()) {\n    this.bounce();\n  } else if (this.isOffCanvas()) {\n    this.reset();\n    return;\n  }\n\n  this.px += this.dx;\n  this.py += this.dy; // drift must be applied after position x/y\n  // as it modifies the values by wave function\n\n  this.updateDrift();\n  this.updateRotation();\n};\n/**\n * progress the particle's rotation value according\n * to the settings given\n */\n\n\nSparticle.prototype.updateRotation = function () {\n  if (this.settings.rotate && this.settings.rotation) {\n    this.rotation += this.dr;\n  }\n};\n/**\n * progress the particle's drift value according\n * to the settings given\n */\n\n\nSparticle.prototype.updateDrift = function () {\n  var _ = this.settings;\n  var dir = _.direction;\n\n  if (_.drift && _.speed) {\n    if (this.vertical) {\n      // apply HORIZONTAL drift ~ when \"direction\" is mostly vertical.\n      this.px += cartesian(this.frame + this.frameoffset)[0] * this.dd / (this.getDelta() * 15);\n    } else if (this.horizontal) {\n      // apply VERTICAL drift ~ when \"direction\" is mostly horizontal.\n      this.py += cartesian(this.frame + this.frameoffset)[1] * this.dd / (this.getDelta() * 15);\n    }\n  }\n};\n\nSparticle.prototype.render = function (canvasses) {\n  var particleCanvas;\n\n  if (this.shape !== \"image\") {\n    particleCanvas = canvasses[this.color][this.shape][this.style];\n  } else {\n    particleCanvas = canvasses[this.color][this.shape][this.image];\n  }\n\n  var canvasSize = particleCanvas.width;\n  var scale = this.size / canvasSize;\n  var px = this.px / scale;\n  var py = this.py / scale;\n  this.ctx.globalAlpha = clamp(this.alpha, 0, 1);\n  this.renderRotate();\n  this.ctx.transform(scale, 0, 0, scale, 0, 0);\n  this.ctx.drawImage(particleCanvas, 0, 0, canvasSize, canvasSize, px, py, canvasSize, canvasSize);\n  this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n  return this;\n};\n\nSparticle.prototype.renderRotate = function () {\n  if (this.shape !== \"circle\" && this.settings.rotate) {\n    var centerX = this.px + this.size / 2;\n    var centerY = this.py + this.size / 2;\n    this.ctx.translate(centerX, centerY);\n    this.ctx.rotate(this.rotation);\n    this.ctx.translate(-centerX, -centerY);\n  }\n};\n\n/**\n * Sparticles Constructor;\n * Create a <canvas>, append to the given node, and start the particle effect\n * @param {HTMLElement} [node=document.body] - element to which canvas is appended to\n * @param {Object} [options={}] - settings to use for the particle effect\n * @param {String} [options.composition=source-over] - canvas globalCompositeOperation value for particles\n * @param {Number} [options.count=50] - number of particles on the canvas simultaneously\n * @param {Number} [options.speed=10] - default velocity of every particle\n * @param {Number} [options.parallax=1] - speed multiplier effect for larger particles (0 = none)\n * @param {Number} [options.direction=180] - default direction of particles in degrees (0 = ↑, 180 = ↓)\n * @param {Number} [options.xVariance=2] - random deviation of particles on x-axis from default direction\n * @param {Number} [options.yVariance=2] - random deviation of particles on y-axis from default direction\n * @param {Number} [options.rotate=true] - can particles rotate\n * @param {Number} [options.rotation=1] - default rotational speed for every particle\n * @param {Number} [options.alphaSpeed=10] - rate of change in alpha over time\n * @param {Number} [options.alphaVariance=1] - random deviation of alpha change\n * @param {Number} [options.minAlpha=0] - minumum alpha value of every particle\n * @param {Number} [options.maxAlpha=1] - maximum alpha value of every particle\n * @param {Number} [options.minSize=1] - minimum size of every particle\n * @param {Number} [options.maxSize=10] - maximum size of every particle\n * @param {Boolean} [options.bounce=false] - should the particles bounce off edge of canvas\n * @param {Number} [options.drift=1] - the \"driftiness\" of particles which have a horizontal/vertical direction\n * @param {Number} [options.glow=0] - the glow effect size of each particle\n * @param {Boolean} [options.twinkle=false] - particles to exhibit an alternative alpha transition as \"twinkling\"\n * @param {String} [options.style=fill] - fill style of particles (one of; \"fill\", \"stroke\" or \"both\")\n * @param {(String|String[])} [options.shape=circle] - shape of particles (any of; circle, square, triangle, diamond, line, image) or \"random\"\n * @param {(String|String[])} [options.imageUrl=] - if shape is \"image\", define an image url (can be data-uri, must be square (1:1 ratio))\n * @param {(String|String[])} [options.color=random] - css color as string, or array of color strings (can also be \"random\")\n * @param {Function} [options.randomColor=randomHsl(index,total)] - a custom function for setting the random colors when color=\"random\"\n * @param {Number} [options.randomColorCount=3] - the number of random colors to generate when color is \"random\"\n * @param {Number} [width] - the width of the canvas element\n * @param {Number} [height=width] - the height of the canvas element\n * @returns {Object} - reference to a new Sparticles instance\n */\n\nvar Sparticles = function Sparticles(node, options, width, height) {\n  if (arguments.length >= 1 && !(arguments[0] instanceof HTMLElement)) {\n    options = arguments[0];\n    width = arguments[1];\n    height = arguments[2];\n    node = undefined;\n  }\n\n  if (width && !height) {\n    height = width;\n  }\n\n  var defaults = {\n    alphaSpeed: 10,\n    alphaVariance: 1,\n    bounce: false,\n    color: \"random\",\n    randomColor: randomHsl,\n    randomColorCount: 3,\n    composition: \"source-over\",\n    count: 50,\n    direction: 180,\n    drift: 1,\n    glow: 0,\n    imageUrl: \"\",\n    maxAlpha: 1,\n    maxSize: 10,\n    minAlpha: 0,\n    minSize: 1,\n    parallax: 1,\n    rotate: true,\n    rotation: 1,\n    shape: \"circle\",\n    speed: 10,\n    style: \"fill\",\n    twinkle: false,\n    xVariance: 2,\n    yVariance: 2\n  };\n  this.el = node || document.body;\n  this.settings = _objectSpread2(_objectSpread2({}, defaults), options);\n  this.resizable = !width && !height;\n  this.width = this.resizable ? this.el.clientWidth : width;\n  this.height = this.resizable ? this.el.clientHeight : height;\n  /**\n   * initialise the sparticles instance\n   * @returns {Object} - reference to the Sparticles instance\n   */\n\n  this.init = function () {\n    var _this = this;\n\n    this.sparticles = [];\n    this.colors = this.getColorArray();\n    this.shapes = this.getShapeArray();\n    this.styles = this.getStyleArray();\n    this.imageUrls = this.getImageArray();\n    this.setupMainCanvas();\n    this.setupOffscreenCanvasses(function () {\n      _this.createSparticles();\n\n      _this.start();\n    }); // defer to the default \"handleEvent\" handler\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventListener/handleEvent\n\n    window.addEventListener(\"resize\", this);\n    return this;\n  };\n  /**\n   * handle event for screen resize;\n   * debounce a canvas resize,\n   * reset the particles\n   */\n\n\n  this.handleEvent = function (event) {\n    var _this2 = this;\n\n    if (event.type === \"resize\") {\n      clearTimeout(this.resizeTimer);\n      this.resizeTimer = setTimeout(function () {\n        if (_this2.resizable) {\n          _this2.width = _this2.el.clientWidth;\n          _this2.height = _this2.el.clientHeight;\n\n          _this2.setCanvasSize().resetSparticles();\n        }\n      }, 200);\n    }\n  };\n  /**\n   * start/resume the sparticles animation\n   * @returns {Object} - the Sparticle instance (for chaining)\n   */\n\n\n  this.start = function () {\n    var me = this;\n\n    if (!this.loop) {\n      this.loop = new AnimationFrame(function (t) {\n        me.drawFrame(t);\n      });\n    }\n\n    this.loop.start();\n    return this;\n  };\n  /**\n   * stop/pause the sparticles animation\n   * @returns {Object} - the Sparticle instance (for chaining)\n   */\n\n\n  this.stop = function () {\n    this.loop.stop();\n    return this;\n  };\n  /**\n   * destroy the current instance and free up some memory\n   * @returns {Object} - the Sparticle instance (for chaining)\n   */\n\n\n  this.destroy = function () {\n    // stop the rendering and updating\n    this.stop(); // remove the canvas element from the DOM\n\n    this.el.removeChild(this.canvas); // remove the resize event for this instance\n\n    window.removeEventListener(\"resize\", this); // delete all the properties from the instance\n    // to free up memory\n\n    for (var prop in this) {\n      if (this.hasOwnProperty(prop)) {\n        delete this[prop];\n      }\n    }\n\n    return this;\n  };\n  /**\n   * set the canvas width and height\n   * @param {Number} width - the width of the canvas\n   * @param {Number} height - the height of the canvas\n   * @returns {Object} - the Sparticle instance (for chaining)\n   */\n\n\n  this.setCanvasSize = function (width, height) {\n    if (width) {\n      this.resizable = false;\n    }\n\n    this.width = width || this.width;\n    this.height = height || this.height;\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    return this;\n  };\n  /**\n   * create an array and populate it with new Sparticle instances.\n   * @returns {Array} the array of Sparticle instances\n   */\n\n\n  this.resetSparticles = this.createSparticles = function () {\n    this.sparticles = [];\n    this.ctx.globalCompositeOperation = this.settings.composition;\n\n    for (var i = 0; i < this.settings.count; i++) {\n      this.sparticles.push(new Sparticle(this, i));\n    }\n\n    this.sort();\n    return this.sparticles;\n  };\n  /**\n   * sort the particle array by size so that parallax effect\n   * doesn't appear to have slower/smaller particles in foreground\n   */\n\n\n  this.sort = function () {\n    if (this.settings.parallax) {\n      this.sparticles.sort(function (a, b) {\n        return a.size - b.size;\n      });\n    }\n  }; // initialise the sparticles, and return the instance.\n\n\n  return this.init();\n};\n/**\n * convert the input color to an array if it isn't already\n * @returns {Array} - array of colors for use in rendering\n */\n\n\nSparticles.prototype.getColorArray = function () {\n  var colors = Array.isArray(this.settings.color) ? this.settings.color : [this.settings.color];\n  var isRandom = colors.some(function (c) {\n    return c === \"random\";\n  });\n\n  if (isRandom) {\n    for (var i = 0; i < this.settings.randomColorCount; i++) {\n      colors[i] = this.settings.randomColor(i, this.settings.randomColorCount);\n    }\n  }\n\n  return colors;\n};\n/**\n * convert the input shape to an array if it isn't already\n * @returns {Array} - array of shapes for use in rendering\n */\n\n\nSparticles.prototype.getShapeArray = function () {\n  var shapes = Array.isArray(this.settings.shape) ? this.settings.shape : [this.settings.shape];\n  var isRandom = shapes.some(function (c) {\n    return c === \"random\";\n  });\n\n  if (isRandom) {\n    shapes = [\"square\", \"circle\", \"triangle\"];\n  }\n\n  return shapes;\n};\n/**\n * convert the imageUrl option to an array if it isn't already\n * @returns {Array} - array of image urls for use in rendering\n */\n\n\nSparticles.prototype.getImageArray = function () {\n  return Array.isArray(this.settings.imageUrl) ? this.settings.imageUrl : [this.settings.imageUrl];\n};\n/**\n * convert the input style to an array\n * @returns {Array} - array of styles for use in rendering\n */\n\n\nSparticles.prototype.getStyleArray = function () {\n  var styles = this.settings.style;\n\n  if (styles !== \"fill\" && styles !== \"stroke\") {\n    styles = [\"fill\", \"stroke\"];\n  } else {\n    styles = [styles];\n  }\n\n  return styles;\n};\n/**\n * set up the canvas and bind to a property for\n * access later on, append it to the DOM\n * @returns {HTMLCanvasElement} - the canvas element which was appended to DOM\n */\n\n\nSparticles.prototype.setupMainCanvas = function () {\n  this.canvas = document.createElement(\"canvas\");\n  this.canvas.setAttribute(\"class\", \"sparticles\");\n  this.ctx = this.canvas.getContext(\"2d\");\n  this.setCanvasSize();\n  this.el.appendChild(this.canvas);\n  return this.canvas;\n};\n/**\n * create a new offscreen canvas element for each color & shape\n * combination, so that we can reference it later during render\n * (huge performance gains here)\n * @param {Function} [callback] - function to execute after image loads\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.setupOffscreenCanvasses = function (callback) {\n  var _this3 = this;\n\n  var colors = this.colors.filter(function (item, index) {\n    return _this3.colors.indexOf(item) === index;\n  });\n  var shapes = this.shapes.filter(function (item, index) {\n    return _this3.shapes.indexOf(item) === index;\n  });\n  var styles = this.styles.filter(function (item, index) {\n    return _this3.styles.indexOf(item) === index;\n  });\n  var imageUrls = this.imageUrls.filter(function (item, index) {\n    return _this3.imageUrls.indexOf(item) === index;\n  });\n  var imageCount = colors.length * imageUrls.length;\n  var canvasCount = colors.length * shapes.length * styles.length;\n  var imagesLoaded = 0;\n  var canvassesCreated = 0;\n  this.canvasses = this.canvasses || {};\n  colors.forEach(function (color) {\n    _this3.canvasses[color] = _this3.canvasses[color] || {};\n    shapes.forEach(function (shape) {\n      _this3.canvasses[color][shape] = _this3.canvasses[color][shape] || {};\n\n      if (shape === \"image\") {\n        imageUrls.forEach(function (imageUrl, i) {\n          var image = new Image();\n          var imageCanvas = document.createElement(\"canvas\");\n          _this3.canvasses[color][shape][imageUrl] = imageCanvas;\n\n          image.onload = function () {\n            imagesLoaded++;\n\n            _this3.drawOffscreenCanvasForImage(image, color, imageCanvas);\n\n            if (callback && imagesLoaded === imageCount) {\n              callback();\n            }\n          };\n\n          image.onerror = function () {\n            console.error(\"failed to load source image: \", imageUrl);\n          };\n\n          image.src = imageUrl;\n        });\n      } else {\n        styles.forEach(function (style) {\n          var canvas = document.createElement(\"canvas\");\n          _this3.canvasses[color][shape][style] = canvas;\n          canvassesCreated++;\n\n          _this3.drawOffscreenCanvas(shape, style, color, canvas);\n\n          if (callback && canvassesCreated === canvasCount) {\n            callback();\n          }\n        });\n      }\n    });\n  });\n};\n/**\n * return the size of the glow effect (shadowBlur) for each particle\n * @param {Number} size - the size of the particle\n * @returns {Number} - the size of the glow/shadow\n */\n\n\nSparticles.prototype.getGlowSize = function (size) {\n  return this.settings.glow;\n};\n/**\n * return the outline or stroke size of each particle\n * @param {Number} size - the size of the particle\n * @returns {Number} - the size of the outline/stroke\n */\n\n\nSparticles.prototype.getLineSize = function (size) {\n  return clamp(size / 20, 1, 5);\n};\n/**\n * return the offscreenCanvas size to generate for\n * @returns {Number} - the maxSize of the offscreen canvas\n */\n\n\nSparticles.prototype.getOffscreenCanvasSize = function () {\n  return clamp(this.settings.maxSize, this.settings.minSize, this.settings.maxSize);\n};\n/**\n * set the fill/stroke style (color & width) for each particle's offscreen canvas\n * @param {CanvasRenderingContext2D} ctx - the canvas context\n * @param {String} color - the color to fill/stroke with\n * @param {Number} lineSize - size/thickness of the stroke\n * @param {String} style - style (either \"fill\" or \"stroke\")\n */\n\n\nSparticles.prototype.renderStyle = function (ctx, color, lineSize, style) {\n  if (style === \"fill\") {\n    ctx.fillStyle = color;\n  } else {\n    ctx.lineWidth = lineSize;\n    ctx.strokeStyle = color;\n  }\n};\n/**\n * set the shadowBlur (glow effect) for each particle's offscreen canvas\n * @param {CanvasRenderingContext2D} ctx - the canvas context\n * @param {String} color - the color to fill/stroke with\n * @param {Number} size - size of the shadow/glow\n */\n\n\nSparticles.prototype.renderGlow = function (ctx, color, size) {\n  var glowSize = this.getGlowSize(size) / 2;\n  ctx.shadowColor = color;\n  ctx.shadowBlur = glowSize;\n};\n/**\n * fill or stroke each particle's offscreen canvas depending on the given setting\n * @param {CanvasRenderingContext2D} ctx - the canvas context\n * @param {String} style - style (either \"fill\" or \"stroke\")\n */\n\n\nSparticles.prototype.renderColor = function (ctx, style, path) {\n  if (style === \"fill\") {\n    if (path) {\n      ctx.fill(path);\n    } else {\n      ctx.fill();\n    }\n  } else {\n    if (path) {\n      ctx.stroke(path);\n    } else {\n      ctx.stroke();\n    }\n  }\n};\n/**\n * pass-through the needed parameters to the offscreen canvas\n * draw function associated with the given shape\n * @param {String} shape -  shape of the canvas to draw (eg: \"circle\")\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.drawOffscreenCanvas = function (shape, style, color, canvas) {\n  return this.offScreenCanvas[shape].call(this, style, color, canvas);\n};\n/**\n * object of shapes to draw\n */\n\n\nSparticles.prototype.offScreenCanvas = {};\n/**\n * create, setup and render an offscreen canvas for a\n * Circle Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\nSparticles.prototype.offScreenCanvas.circle = function (style, color, canvas) {\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize();\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var shapeSize = style === \"stroke\" ? size - lineSize : size;\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  this.renderGlow(ctx, color, size);\n  this.renderStyle(ctx, color, lineSize, style);\n  ctx.beginPath();\n  ctx.ellipse(canvasSize / 2, canvasSize / 2, shapeSize / 2, shapeSize / 2, 0, 0, 360);\n  this.renderColor(ctx, style);\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Square Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.offScreenCanvas.square = function (style, color, canvas) {\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize();\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var shapeSize = style === \"stroke\" ? size - lineSize : size;\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  this.renderGlow(ctx, color, size);\n  this.renderStyle(ctx, color, lineSize, style);\n  ctx.beginPath();\n  ctx.rect(canvasSize / 2 - shapeSize / 2, canvasSize / 2 - shapeSize / 2, shapeSize, shapeSize);\n  this.renderColor(ctx, style);\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Line/Curve Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.offScreenCanvas.line = function (style, color, canvas) {\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize() * 1.5;\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var startx = canvasSize / 2 - size / 2;\n  var starty = canvasSize / 2 - size / 2;\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  this.renderGlow(ctx, color, size);\n  ctx.lineWidth = lineSize;\n  ctx.strokeStyle = color;\n  ctx.beginPath();\n  ctx.moveTo(startx, starty);\n  ctx.lineTo(startx + size, starty + size);\n  ctx.stroke();\n  ctx.closePath();\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Triangle Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.offScreenCanvas.triangle = function (style, color, canvas) {\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize();\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var shapeSize = style === \"stroke\" ? size - lineSize : size;\n  var height = shapeSize * (Math.sqrt(3) / 2);\n  var startx = canvasSize / 2;\n  var starty = canvasSize / 2 - shapeSize / 2;\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  this.renderGlow(ctx, color, size);\n  this.renderStyle(ctx, color, lineSize, style);\n  ctx.beginPath();\n  ctx.moveTo(startx, starty);\n  ctx.lineTo(startx - shapeSize / 2, starty + height);\n  ctx.lineTo(startx + shapeSize / 2, starty + height);\n  ctx.closePath();\n  this.renderColor(ctx, style);\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Diamond Sparkle Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.offScreenCanvas.diamond = function (style, color, canvas) {\n  var pathSize = 100;\n  var path = new Path2D(\"M43,83.74,48.63,99a1.46,1.46,0,0,0,2.74,0L57,83.74A45.09,45.09,0,0,1,83.74,57L99,51.37a1.46,1.46,0,0,0,0-2.74L83.74,43A45.11,45.11,0,0,1,57,16.26L51.37,1a1.46,1.46,0,0,0-2.74,0L43,16.26A45.11,45.11,0,0,1,16.26,43L1,48.63a1.46,1.46,0,0,0,0,2.74L16.26,57A45.09,45.09,0,0,1,43,83.74Z\");\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize();\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var scale = canvasSize / ((pathSize + glowSize) * 1.1);\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  this.renderGlow(ctx, color, size);\n  this.renderStyle(ctx, color, lineSize / scale, style);\n  ctx.scale(scale, scale);\n  ctx.translate(pathSize * 0.05 + glowSize * 0.5, pathSize * 0.05 + glowSize * 0.5);\n  this.renderColor(ctx, style, path);\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Star Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.offScreenCanvas.star = function (style, color, canvas) {\n  var pathSize = 100;\n  var path = new Path2D(\"M99.86,36.45a2.94,2.94,0,0,0-2.37-2l-31-4.54L52.63,1.64a2.93,2.93,0,0,0-5.26,0L33.51,29.91l-31,4.54a3,3,0,0,0-2.37,2,3,3,0,0,0,.74,3l22.44,22L18,92.55A2.94,2.94,0,0,0,20.91,96a2.86,2.86,0,0,0,1.36-.34L50,81,77.73,95.66a2.91,2.91,0,0,0,3.08-.22A3,3,0,0,0,82,92.55l-5.3-31.07,22.44-22A3,3,0,0,0,99.86,36.45Z\");\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize();\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var scale = canvasSize / ((pathSize + glowSize) * 1.1);\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  ctx.scale(scale, scale);\n  this.renderGlow(ctx, color, size);\n  this.renderStyle(ctx, color, lineSize / scale, style);\n  ctx.translate(pathSize * 0.05 + glowSize * 0.5, pathSize * 0.05 + glowSize * 0.5);\n  this.renderColor(ctx, style, path);\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Custom Image Particle of the given color\n * @param {HTMLImageElement} image - the image element that has loaded\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.drawOffscreenCanvasForImage = function (image, color, canvas) {\n  var size = image.width;\n  var ctx = canvas.getContext(\"2d\");\n  canvas.width = size;\n  canvas.height = size;\n  ctx.drawImage(image, 0, 0, size, size, 0, 0, size, size);\n  ctx.globalCompositeOperation = \"source-atop\";\n  ctx.fillStyle = color;\n  ctx.fillRect(0, 0, size, size);\n  return canvas;\n};\n/**\n * - wipe the canvas,\n * - update each sparticle,\n * - render each sparticle\n * - sort so that larger particles on top\n * @returns {Array} the array of Sparticle instances\n */\n\n\nSparticles.prototype.drawFrame = function () {\n  this.ctx.clearRect(0, 0, this.width, this.height);\n\n  for (var i = 0; i < this.sparticles.length; i++) {\n    var sparticle = this.sparticles[i];\n    sparticle.update().render(this.canvasses);\n  }\n\n  this.sort();\n  return this.sparticles;\n};\n\nexport default Sparticles;\n"],
  "mappings": "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",
  "names": ["AnimationFrame", "loop", "cartesian", "clamp", "radian", "random", "randomArray", "randomHsl", "roll", "round", "Sparticle", "Sparticles", "width", "height"]
}
